1. STL是由哪些组件构成的？它们各自具备什么样的特点？

STL的六大组件分别是：
容器(contailer)
迭代器(iterator)
适配器(Adapter)
算法(algorithm)
函数对象(functor)
配置器(allocator)

容器：一个容器就是一些特定类型对象的集合，是可以容纳一些数据的类模板。

迭代器：类似于指针类型，迭代器提供了对对象的间接访问。对象可以是容器中的元素或者是string对象中的字符。迭代器是通过重载一元的"*"和"->"来从容器中间接的返回一个值。

适配器：迭代器就是一个接口，可以对容器，迭代器和算法进行包装，但实质还是容器，迭代器和算法类型。本质上，迭代器是一种机制，能使某种事物的行为看起来像另外一种事物一样。

2. 序列式容器都有哪些异同？

序列式容器分为vector,deque,list,forward_list,array,
string类型。

<1>序列式容器中除了array,是固定大小的数组。其他的容器都可以添加和删除元素，扩张和收缩容器的大小。

<2>string和vector将元素保存在连续的内存空间，所以都支持快速访问，时间复杂度是O(1)。但是在这几个容器的中间位置添加和删除元素就会比较耗时。

<3>list和forward_list这两个容器在任何位置的添加和删除都很快，但不支持快速随机访问，访问一个元素需要遍历整个容器。另外和string，vector，deque和array比较，有额外的内存开销。

<4>string和vector支持下标访问运算符，其他的序列式容器都不支持。

3. 关联式容器都有哪些异同？

关联式容器的类型中关键词有序的：map,set,multimap,multiset。
关键词无序的：unorder_map,unorder_set,unorder_multimap,unorder_multiset;

set是只保存关键字的容器，map是保存关键字-键值对<key-value>。multi允许容器中重复关键字。unorder是用哈希函数组织的容器，无序，速度比有序快。

4.词频统计的作业再用map/unordered_map容器去实现一次，体验一下使用vector/map/unordered_map时程序执行的速度。
#include<string>
#include<map>
#include<fstream>
#include<sstream>
#include <iostream>

using std::cout;
using std::endl;

using std::string;

using std::ifstream;
using std::ofstream;
using std::istringstream;

using std::map;

class mapDic
{
public:
	mapDic()
	{}
	
	void read(const string &filename)
	{
		ifstream ifs(filename);
		
		if(!ifs)
		{
			cout<<"ifstream open error!";
			return;
		}

		string line;
		int count=0;

		while(getline(ifs,line))
		{
			istringstream iss(line);
			string word;

			while(iss>>word)
			{
				if(isWord(word))
				{
					++_work_count[word];
				}
			}

			++count;
			if((count%1000)==0)
			{
				cout<<"count="<<count<<endl;
			}

		}

		ifs.close();	
	}
	
	void store(const string &filename)
	{
		ofstream ofs(filename);
		
		if(!ofs)
		{
			cout<<"ofstream open error!"<<endl;
			return;
		}

		for(const auto &w:_work_count)
		{
			ofs<<w.first<<" "<<w.second<<"\n";
		}

		ofs.close();
	}

private:
	bool isWord(const string &word)
	{
		for(size_t idx=0;idx!=word.size();++idx)
		{
			if(isdigit(word[idx]))
			{
				return false;
			}

			return true;
		}
	}
	
private:
	map<string,size_t> _work_count;
};

int main(void)
{
	mapDic mapdic;
	
	mapdic.read("The_Holy_Bible.txt");
	mapdic.store("mapdic.dat");
	
	return 0;
}


5. 实现一个堆排序算法

   可选择使用模板或非模板的实现：
   
   使用模板的框架如下：
    template <typename T, typename Compare = std::less<T> >
    class HeapSort
    {
    public:
        HeapSort(T * arr, int size);        
        void heapAdjust();
        void sort();    
    private:
        //...
    };
	