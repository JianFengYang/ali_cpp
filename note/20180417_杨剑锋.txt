0. 什么是友元？友元的存在形式有？友元有何特点？

一般类的私有成员只能在类的内部访问，但可以将一个函数或者一个类定义为友元函数或者友元类，这样就可以访问此类的私有成员了。友元的存在形式有友元函数和友元类。友元是单向的，不具备传递性，不能被继承。

1. 运算符重载的原则是什么？有哪些规则？
            
运算符的重载是通过把C++中预定义的运算符重载为类的成员函数或者友元函数，为了使对用户自定义数据类型的数据的操作与内置的数据库型的数据操作形式一致。

重载操作符必须具有一个类类型或者枚举类型的操作数。
优先级和结合性是固定的。
不再具备短路求值特性。
不能臆造并且重载一个不存在的运算符。

2. 不能重载的运算符有哪几个？

不能重载的运算符有：成员运算符. 
成员指针访问运算符 .*  域运算符 ::
长度运算符 sizeof     条件运算符号 ?:

3. 运算符重载的形式有哪几种？

运算符的重载形式有三种：

1 采用普通函数的重载形式
2 采用友元函数的重载形式
3 采用成员函数的重载形式

4.  自增自减运算符的区别？其形式是怎样的？返回值类型分别是什么？
	自增自减运算符有前自运算符和后自运算符，前自运算符先自运算，直接返回自身，而后自运算要用一个临时对象保存自身初始状态，然后进行增减，返回临时对象。这导致了前自运算效率高，后自运算效率低。
	前自增和前自减为：++i，—i；后自增和后自减为：i++，i—。
	前自运算返回自身的引用，后自运算返回一个匿名临时对象。


5. 实现String类的其它运算符的重载

class String {
public:
	String();
	String(const char *);
	String(const String&);
	~String();
	String &operator=(const String &);
	String &operator=(const char *);

	String &operator+=(const String &);
	String &operator+=(const char *);

	char &operator[](std::size_t index);
	const char &operator[](std::size_t index) const;

	std::size_t size() const;
	const char* c_str() const;

	friend bool operator==(const String &, const String &);
	friend bool operator!=(const String &, const String &);

	friend bool operator<(const String &, const String &);
	friend bool operator>(const String &, const String &);
	friend bool operator<=(const String &, const String &);
	friend bool operator>=(const String &, const String &);

	friend std::ostream &operator<<(std::ostream &os, const String &s);
	friend std::istream &operator>>(std::istream &is, String &s);

private:
	char * _pstr;
};

String operator+(const String &, const String &);
String operator+(const String &, const char *);
String operator+(const char *, const String &);


#include <iostream>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
using std::cout;
using std::endl;
using std::ws;
String::String():_pstr(new char[1]())
{};

String::String(const char *str)
:_pstr(new char [strlen(str)+1]())
{
	strcpy(_pstr,str);
}

String::String(const String &str)
:pstr(new char[str.size()+1])
{
	strcpy(_pstr,str.c_str());
}

String::~String()
{
	delete []_pstr;
}

String &String::operator=(const String &str)
{
	if(str==*this)//equal,return this
	{
		return *this;
	}
	delete []_pstr;//閲婃斁宸︽搷浣滄暟绌洪棿
	_pstr=new char[str.size()+1];
	strcpy(_pstr,str.c_str());
	return *this;
}

String &String::operator=(const char *str)
{
	delete []_pstr;
	_pstr=new char[strlen(str)+1]();
	strcpy(_pstr,str);
	return *this;
}

String &String::operator+=(const String &str)
{
	String _str(_pstr);
	delete []_pstr;
	_pstr=new char[_str.size()+str.size()+1]();

	strcpy(_pstr,_str.c_str());
	strcat(_pstr,str.c-str());

	return *this;
}

String &String::operator+=(const char *str)
{
	String temp(_pstr);
	delete []_pstr;
	_pstr=new char[temp.size()+strlen(str)+1]();
	strcpy(_pstr,temp.c_str());
	strcat(_pstr,str);

	return *this;
}

char &String::operator[](std::size_t i)
{
	if(i<size())
	{
		return _pstr[i];
	}else{
		exit(1)
	}
}

const char &String::operator[](std::size_t i) const
{
	if(i<size())
		return _pstr[i];
	else
		return;
}

std::size_t String::size() const
{
	return strlen(_pstr);
}

const char *String::c_str() const
{
	return _pstr;
}

bool operator==(const String &str1,const String &str2)
{
	if(0==strcmp(str1.c_str(),str2.c_str()))
	{
		return true;
	}else{
	return false;
	}
}

bool operator!=(const String &str1,const String &str2)
{
	if(0==strcmp(str1.c_str(),str2.c_str()))
	{
		return false;
	}
	return true;
}

bool operator<(const String &str1,const String &str2)
{
	if(str1.size()<str2.size())
	{
		return true;
	}
	return false;
}

bool operator>(const String &str1,const String &str2)
{
	if(str1.size()>str2.size())
	{
		return true;
	}
	return false;
}

std::ostream &operator<<(std::ostream &os,const String &s)
{
	return os<<s.c_str();
}

std::istream &operator>>(std::istream &is,String &s)
{
	s=""; 
	is>>ws;
	char c;
	while(is.get(c),!is.eof())
		s+=c;
	return is;
}

String operator+(const String &str1,const String &str2)
{
	String temp(str1);
	temp+=str2;
	return temp;
}

String operator+(const char *str1,const String &str2)
{
	String temp(str1);
	return temp+=str2;
}
