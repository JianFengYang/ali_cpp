1. 实现只能生成栈对象的代码
#include<string.h>
#include <iostream>
using std::cout;
using std::endl;

class Student
{
public:
	Student(int  id,const char *name)
	:_id(id)
	,_name(new char[strlen(name)+1]())
	{
		strcpy(_name,name);
		cout<<"Student(int,const char *)"<<endl;
	}

	void print() const
	{
		cout<<"id:"<<_id<<endl
			<<"name:"<<_name<<endl;
	}

	~Student()
	{
		cout<<"~Student()"<<endl;
		delete []_name;
	}
private:
	int  _id;
	char *_name;

	void *operator new(size_t sz);
	void operator delete(void *ret);
};

int main(void)
{
	Student stu(100,"yjf");
	stu.print();
	return 0;
}



2. 实现只能生成堆对象的代码
#include <stdlib.h>
#include<string.h>
#include <iostream>
using std::cout;
using std::endl;

class Student
{
public:
	Student(int id,const char *name)
	:_id(id)
	,_name(new char[strlen(name)+1]())
	{
		strcpy(_name,name);
		cout<<"Student(int ,const char *)"<<endl;
	}

	void print() const
	{
		cout<<"id:"<<_id<<endl;
		cout<<"name:"<<_name<<endl;
	}

	void destroy()
	{
		delete this;
	}
private:
	//构造栈对象时，构造函数和析构函数都必须是public
	~Student()
	{
		cout<<"~Student()"<<endl;
		delete []_name;
	}

	int _id;
	char *_name;
};

int main(void)
{
	Student *pstu=new Student(100,"yjf");
	pstu->print();
	pstu->destroy();

	return 0;
}

3. 统计一篇英文(The_Holy_Bible.txt)文章中出现的单词和词频，
   输入：某篇文章的绝对路径
   输出：词典（词典中的内容为每一行都是一个“单词 词频”）
   
   词典的存储格式如下
 -----------------
|   a 66          |
|   abandon 77    |
|   public 88     |
|    ......	      |
|_________________|
	
	class Dictionary
	{
	public:
			//......
	    void read(const std::string & filename);
	    void store(const std::string &filename);
	private:
	    //......
	};
#include<iostream>
#include<string>
#include<algorithm>
#include<fstream>
#include<sstream>

#include<string.h>

using std::cout;
using std::endl;

using std::string;

using std::ifstream;
using std::ofstream;
using std::istringstream;

using std::vector;

struct Record
{
	Record(const string &word,int freq)
		:_word(word)
		 ,_freq(freq)
	{
	}
	string _word;
	int _freq;
};


class Dictionary
{
	public:
		Dictionary()
		{
			_dict.reserve(1000);
		}

		void read(const string &filename)
		{
			ifstream ifs(filename);
			if(!ifs)
			{
				cout<<"ifstream open error"<<endl;
				return;
			}


			string line;
			int count=0;

			while(getline(ifs,line))
			{
				istringstream iss(line);
				string word;

				while(iss>>word)
				{
					if(isWord(word))
					{
						processWord(word);
					}
				}

				++count;
				if((count%1000)==0)
				{
					cout<<"count="<<count<<endl;
				}
			}

			ifs.close();
			std::sort(_dict.begin(),_dict.end());

		}


		void store(const string &filename)
		{
			ofstream ofs(filename);
			if(!ofs)
			{
				cout<<"ofstream open error"<<endl;
				return;
			}

			for(auto &record:_dict)
			{
				ofs<<record._word<<" "<<record._freq<<"\n";


			}

			ofs.close();

		}
	private:
		bool isWord(const string &word)
		{
			for(size_t idx=0;idx!=word.size();++idx)
			{
				if(isdigit(word[idx]))
					return false;
			}
			return true;
		}

		void processWord(const string &word)
		{
			size_t idx;
			for(idx=0;idx!=_dict.size();++idx)
			{
				if(_dict[idx]._word==word)
				{
					++_dict[idx]._freq;
					break;
				}
			}

			if(idx>=_dict.size())
			{
				_dict.push_back(Record(word,1));
			}
		}
	private:
		vector<Record> _dict;
};

int main(void)
{
	Dictionary dictionary;
	dictionary.read("The_Holy_Bible.txt");
	dictionary.store("dictionary.dat");
	return 0;
}


